# these types and functions integrate the Boltzmann hierarchy through time

#for now just for photons, swap ‚Ñì·µß for N·µß the number of IE conformal time integration points
#at the moment neutrinos are still hierarchy, will eventually replace neutrinos as well
struct IE{T<:Real, PI<:PerturbationIntegrator, CP<:AbstractCosmoParams{T},
                 BG<:AbstractBackground, IH<:AbstractIonizationHistory, Tk<:Real,
				 IT<:AbstractInterpolation{T,1}}
    integrator::PI
    par::CP
    bg::BG
    ih::IH
    k::Tk
    sŒò2::IT
    sŒ†::IT
    N·µß::Int #can't we just use existing x grid for this?
    ‚Ñì_ŒΩ::Int
    ‚Ñì_mŒΩ::Int
    nq::Int
end

IE(integrator::PerturbationIntegrator, par::AbstractCosmoParams, bg::AbstractBackground,
    ih::AbstractIonizationHistory, k::Real,
    sŒò2::AbstractInterpolation,sŒ†::AbstractInterpolation,
	#^FIXME: Are these right?? I dropped the {T,1} since T is not known here to get it to compile
    N·µß=400, ‚Ñì_ŒΩ=8, ‚Ñì_mŒΩ=10, nq=15
    ) = IE(integrator, par, bg, ih, k, sŒò2, sŒ†, N·µß, ‚Ñì_ŒΩ,‚Ñì_mŒΩ, nq)


function iesolve(ie,u,Œò‚ÇÇ,Œ†)
	#ie is the existing integrator
	#u is history of perts
	xx = ie.bg.x_grid
	# Œò‚ÇÇ,Œ† = zeros(ie.N·µß), zeros(ie.N·µß) #local arrays #TODO maybe make ie attributes?
    for i in 2:length(xx)
		Œò‚ÇÇ[i],Œ†[i] = g_weight_trapz_ie(xx[i],ie,u[i])
	end
end

function itersolve(ie)
    # initialize ansatz - start with zero
	Œò‚ÇÇ,Œ† = zeros(ie.N·µß),zeros(ie.N·µß)
    # start picard iteration

        # update splines
		ie.Œò‚ÇÇ = spline(Œò‚ÇÇ, ie.bg.x_grid)
		ie.Œ† =  spline(Œ†,  ie.bg.x_grid)
        # solve odes
		perturb = boltsolve_rsa(ie)

        # solve ie to get Œò‚ÇÇ, Œ† - Picard step with weights for coupling is here
		iesolve(ie,perturb.u,Œò‚ÇÇ,Œ†)

end


function boltsolve(ie::IE{T}, ode_alg=KenCarp4(); reltol=1e-6) where T #MD...
    x·µ¢ = first(ie.bg.x_grid)
    u‚ÇÄ = initial_conditions(x·µ¢, ie)
    prob = ODEProblem{true}(ie!, u‚ÇÄ, (x·µ¢ , zero(T)), ie)
    sol = solve(prob, ode_alg, reltol=reltol,
                saveat=ie.bg.x_grid, dense=false,
                )
    return sol
end

function rsa_perts!(u, ie::IE{T},x) where T
    #redundant code for what we need to compute RSA perts in place in u
    k, ‚Ñì·µß, par, bg, ih, nq = ie.k, 2, ie.par, ie.bg, ie.ih,ie.nq
    Œ©_r, Œ©_b, Œ©_m, N_ŒΩ, m_ŒΩ, H‚ÇÄ¬≤ = par.Œ©_r, par.Œ©_b, par.Œ©_m, par.N_ŒΩ, par.Œ£m_ŒΩ, bg.H‚ÇÄ^2 #add N_ŒΩ‚â°N_eff
    ‚Ñã‚Çì, ‚Ñã‚Çì‚Ä≤, Œ∑‚Çì, œÑ‚Çì‚Ä≤, œÑ‚Çì‚Ä≤‚Ä≤ = bg.‚Ñã(x), bg.‚Ñã‚Ä≤(x), bg.Œ∑(x), ih.œÑ‚Ä≤(x), ih.œÑ‚Ä≤‚Ä≤(x)
    a = x2a(x)
    Œ©_ŒΩ =  7*(2/3)*N_ŒΩ/8 *(4/11)^(4/3) *Œ©_r
    csb¬≤ = ih.csb¬≤(x)
    ‚Ñì_ŒΩ = ie.‚Ñì_ŒΩ
    Œò, Œò·µñ, ùí©, ‚Ñ≥, Œ¶, Œ¥, v, Œ¥_b, v_b = unpack(u, ie)  # the Œò, Œò·µñ, ùí© are views (see unpack)

    œÅ‚Ñ≥, œÉ‚Ñ≥  =  œÅ_œÉ(‚Ñ≥[0:nq-1], ‚Ñ≥[2*nq:3*nq-1], bg, a, par) #monopole (energy density, 00 part),quadrupole (shear stress, ij part)
    Œ® = -Œ¶ - 12H‚ÇÄ¬≤ / k^2 / a^2 * (Œ©_r * Œò[2]+
                                  Œ©_ŒΩ * ùí©[2]
                                  + œÉ‚Ñ≥ / bg.œÅ_crit /4
                                  )
    Œ¶‚Ä≤ = Œ® - k^2 / (3‚Ñã‚Çì^2) * Œ¶ + H‚ÇÄ¬≤ / (2‚Ñã‚Çì^2) * (
        Œ©_m * a^(-1) * Œ¥ + Œ©_b * a^(-1) * Œ¥_b
        + 4Œ©_r * a^(-2) * Œò[0]
        + 4Œ©_ŒΩ * a^(-2) * ùí©[0]
        + a^(-2) * œÅ‚Ñ≥ / bg.œÅ_crit
        )

    #fixed RSA
    Œò[0] = Œ¶ - ‚Ñã‚Çì/k *œÑ‚Çì‚Ä≤ * v_b
    Œò[1] = ‚Ñã‚Çì/k * (  -2Œ¶‚Ä≤ + œÑ‚Çì‚Ä≤*( Œ¶ - csb¬≤*Œ¥_b  )
                     + ‚Ñã‚Çì/k*( œÑ‚Çì‚Ä≤‚Ä≤ - œÑ‚Çì‚Ä≤ )*v_b  )
    Œò[2] = 0
    #massless neutrinos
    ùí©[0] = Œ¶
    ùí©[1] = -2‚Ñã‚Çì/k *Œ¶‚Ä≤
    ùí©[2] = 0

    #set polarization to zero
    Œò·µñ[0] = 0
    Œò·µñ[1] = 0
    Œò·µñ[2] = 0

    u[1] = Œò[0]
    u[2] = Œò[1]
    u[3] = Œò[2]

    u[(‚Ñì·µß+1)+1] = Œò·µñ[0]
    u[(‚Ñì·µß+1)+2] = Œò·µñ[1]
    u[(‚Ñì·µß+1)+3] = Œò·µñ[2]

    u[2(‚Ñì·µß+1)+1] = ùí©[0]
    u[2(‚Ñì·µß+1)+2] = ùí©[1]
    u[2(‚Ñì·µß+1)+3] = ùí©[2]

    #zero the rest to avoid future confusion
    for ‚Ñì in 3:(‚Ñì·µß)
        u[‚Ñì] = 0
        u[(‚Ñì·µß+1)+‚Ñì] = 0
    end
    for ‚Ñì in 3:(‚Ñì_ŒΩ) u[2(‚Ñì·µß+1)+‚Ñì] = 0 end
    return nothing
end

function boltsolve_rsa(ie::IE{T}, ode_alg=KenCarp4(); reltol=1e-6) where T
    #call solve as usual first
    perturb = boltsolve(ie, reltol=reltol)
    x_grid = ie.bg.x_grid
    pertlen = 2(2+1)+(ie.‚Ñì_ŒΩ+1)+(ie.‚Ñì_mŒΩ+1)*ie.nq+5
    results=zeros(pertlen,length(x_grid))
    for i in 1:length(x_grid) results[:,i] = perturb(x_grid[i]) end
    #replace the late-time perts with RSA approx (assuming we don't change rsa switch)
    this_rsa_switch = x_grid[argmin(abs.(ie.k .* ie.bg.Œ∑.(x_grid) .- 45))]
    x_grid_rsa = x_grid[x_grid.>this_rsa_switch]
    results_rsa = results[:,x_grid.>this_rsa_switch]
    #(re)-compute the RSA perts so we can write them to the output vector
    for i in 1:length(x_grid_rsa) #inside here use regular unpack since single step
        rsa_perts!(view(results_rsa,:,i),ie,x_grid_rsa[i]) #to mutate need to use view...
    end
    results[:,x_grid.>this_rsa_switch] = results_rsa
    sol = results
    return sol
end

# basic Newtonian gauge: establish the order of perturbative variables in the ODE solve
function unpack(u, ie::IE{T, BasicNewtonian}) where T
    ‚Ñì_ŒΩ =  ie.‚Ñì_ŒΩ
    ‚Ñì_mŒΩ = ie.‚Ñì_mŒΩ #should be smaller than others
    nq = ie.nq
    ‚Ñì·µß=2
    Œò = OffsetVector(view(u, 1:(‚Ñì·µß+1)), 0:‚Ñì·µß)  # indexed 0 through ‚Ñì·µß
    Œò·µñ = OffsetVector(view(u, (‚Ñì·µß+2):(2‚Ñì·µß+2)), 0:‚Ñì·µß)  # indexed 0 through ‚Ñì·µß
    ùí© = OffsetVector(view(u, (2(‚Ñì·µß+1) + 1):(2(‚Ñì·µß+1)+‚Ñì_ŒΩ+1)) , 0:‚Ñì_ŒΩ)  # indexed 0 through ‚Ñì_ŒΩ
    ‚Ñ≥ = OffsetVector(view(u, (2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+1):(2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq )) , 0:(‚Ñì_mŒΩ+1)*nq -1)  # indexed 0 through ‚Ñì_mŒΩ
    Œ¶, Œ¥, v, Œ¥_b, v_b = view(u, ((2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq)+1 :(2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq)+5)) #getting a little messy...
    return Œò, Œò·µñ, ùí©, ‚Ñ≥, Œ¶, Œ¥, v, Œ¥_b, v_b
end

#FIXME this is probably terrible for performance
function ie_unpack(u, ie::IE{T, BasicNewtonian}) where T
    ‚Ñì_ŒΩ =  ie.‚Ñì_ŒΩ
    ‚Ñì_mŒΩ = ie.‚Ñì_mŒΩ #should be smaller than others
    nq = ie.nq
    N·µß = ie.N·µß
    ‚Ñì·µß=2
    #here u is the history of u over all ie timesteps (perlen,ie timesteps)
    #The perts below will be their histories over all ie timesteps as well
    #leading index will be pert index, trailing the time index
    Œò = OffsetArray(view(u, 1:(‚Ñì·µß+1),:), 0:‚Ñì·µß, 1:N·µß)  # indexed 0 through ‚Ñì·µß, 1 through N·µß
    Œò·µñ = OffsetArray(view(u, (‚Ñì·µß+2):(2‚Ñì·µß+2),:), 0:‚Ñì·µß, 1:N·µß)  # indexed 0 through ‚Ñì·µß
    ùí© = OffsetArray(view(u, (2(‚Ñì·µß+1) + 1):(2(‚Ñì·µß+1)+‚Ñì_ŒΩ+1),:) , 0:‚Ñì_ŒΩ, 1:N·µß)  # indexed 0 through ‚Ñì_ŒΩ
    ‚Ñ≥ = OffsetArray(view(u, (2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+1):(2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq ),:) , 0:(‚Ñì_mŒΩ+1)*nq-1, 1:N·µß)  # indexed 0 through ‚Ñì_mŒΩ
    # Œ¶, Œ¥, v, Œ¥_b, v_b = view(u, (2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq)+1 :(2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq)+5, :) #getting a little messy...
	Œ¶, Œ¥, v, Œ¥_b, v_b = eachrow( view(u, (2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq)+1 :(2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq)+5, :) ) #getting a little messy...
	return Œò, Œò·µñ, ùí©, ‚Ñ≥, Œ¶, Œ¥, v, Œ¥_b, v_b #perts over all ie timesteps
end

function ie!(du, u, ie::IE{T, BasicNewtonian}, x) where T
    # compute cosmological quantities at time x, and do some unpacking
    k, ‚Ñì·µß, par, bg, ih, nq = ie.k, 2, ie.par, ie.bg, ie.ih, ie.nq
    TŒΩ =  (par.N_ŒΩ/3)^(1/4) *(4/11)^(1/3) * (15/ œÄ^2 *œÅ_crit(par) *par.Œ©_r)^(1/4)
    logqmin,logqmax=log10(TŒΩ/30),log10(TŒΩ*30)
    q_pts = xq2q.(bg.quad_pts,logqmin,logqmax)
    Œ©_r, Œ©_b, Œ©_m, N_ŒΩ, m_ŒΩ, H‚ÇÄ¬≤ = par.Œ©_r, par.Œ©_b, par.Œ©_m, par.N_ŒΩ, par.Œ£m_ŒΩ, bg.H‚ÇÄ^2 #add N_ŒΩ‚â°N_eff
    ‚Ñã‚Çì, ‚Ñã‚Çì‚Ä≤, Œ∑‚Çì, œÑ‚Çì‚Ä≤, œÑ‚Çì‚Ä≤‚Ä≤ = bg.‚Ñã(x), bg.‚Ñã‚Ä≤(x), bg.Œ∑(x), ih.œÑ‚Ä≤(x), ih.œÑ‚Ä≤‚Ä≤(x)
    a = x2a(x)
    R = 4Œ©_r / (3Œ©_b * a)
    Œ©_ŒΩ =  7*(2/3)*N_ŒΩ/8 *(4/11)^(4/3) *Œ©_r
    csb¬≤ = ih.csb¬≤(x)


    ‚Ñì_ŒΩ = ie.‚Ñì_ŒΩ
    ‚Ñì_mŒΩ =  ie.‚Ñì_mŒΩ
    Œò, Œò·µñ, ùí©, ‚Ñ≥, Œ¶, Œ¥, v, Œ¥_b, v_b = unpack(u, ie)  # the Œò, Œò·µñ, ùí© are views (see unpack)
    Œò‚Ä≤, Œò·µñ‚Ä≤, ùí©‚Ä≤, ‚Ñ≥‚Ä≤, _, _, _, _, _ = unpack(du, ie)  # will be sweetened by .. syntax in 1.6
    Œò[2] = ie.sŒò2(x)# call the spline, update Œò‚ÇÇ at top since we do not evolve it


    #do the q integrals for massive neutrino perts (monopole and quadrupole)
    œÅ‚Ñ≥, œÉ‚Ñ≥  =  œÅ_œÉ(‚Ñ≥[0:nq-1], ‚Ñ≥[2*nq:3*nq-1], bg, a, par) #monopole (energy density, 00 part),quadrupole (shear stress, ij part)
    # metric perturbations (00 and ij FRW Einstein eqns)
    Œ® = -Œ¶ - 12H‚ÇÄ¬≤ / k^2 / a^2 * (Œ©_r * Œò[2]+
                                  Œ©_ŒΩ * ùí©[2]#add rel quadrupole
                                  + œÉ‚Ñ≥ / bg.œÅ_crit /4
                                  )

    Œ¶‚Ä≤ = Œ® - k^2 / (3‚Ñã‚Çì^2) * Œ¶ + H‚ÇÄ¬≤ / (2‚Ñã‚Çì^2) * (
        Œ©_m * a^(-1) * Œ¥ + Œ©_b * a^(-1) * Œ¥_b
        + 4Œ©_r * a^(-2) * Œò[0]
        + 4Œ©_ŒΩ * a^(-2) * ùí©[0] #add rel monopole on this line
        + a^(-2) * œÅ‚Ñ≥ / bg.œÅ_crit
        )

    # matter
    Œ¥‚Ä≤ = k / ‚Ñã‚Çì * v - 3Œ¶‚Ä≤
    v‚Ä≤ = -v - k / ‚Ñã‚Çì * Œ®
    Œ¥_b‚Ä≤ = k / ‚Ñã‚Çì * v_b - 3Œ¶‚Ä≤
    v_b‚Ä≤ = -v_b - k / ‚Ñã‚Çì * ( Œ® + csb¬≤ *  Œ¥_b) + œÑ‚Çì‚Ä≤ * R * (3Œò[1] + v_b)

    # neutrinos (massive, MB 57)
    for (i_q, q) in zip(Iterators.countfrom(0), q_pts)
        œµ = ‚àö(q^2 + (a*m_ŒΩ)^2)
        df0 = dlnf0dlnq(q,par)
        #need these factors of 4 on Œ¶, Œ® terms due to MB pert defn
        ‚Ñ≥‚Ä≤[0* nq+i_q] = - k / ‚Ñã‚Çì *  q/œµ * ‚Ñ≥[1* nq+i_q]  + Œ¶‚Ä≤ * df0
        ‚Ñ≥‚Ä≤[1* nq+i_q] = k / (3‚Ñã‚Çì) * ( q/œµ * (‚Ñ≥[0* nq+i_q] - 2‚Ñ≥[2* nq+i_q])  - œµ/q * Œ®  * df0)
        for ‚Ñì in 2:(‚Ñì_mŒΩ-1)
            ‚Ñ≥‚Ä≤[‚Ñì* nq+i_q] =  k / ‚Ñã‚Çì * q / ((2‚Ñì+1)*œµ) * ( ‚Ñì*‚Ñ≥[(‚Ñì-1)* nq+i_q] - (‚Ñì+1)*‚Ñ≥[(‚Ñì+1)* nq+i_q] )
        end
        ‚Ñ≥‚Ä≤[‚Ñì_mŒΩ* nq+i_q] =  q / œµ * k / ‚Ñã‚Çì * ‚Ñ≥[(‚Ñì_mŒΩ-1)* nq+i_q] - (‚Ñì_mŒΩ+1)/(‚Ñã‚Çì *Œ∑‚Çì) *‚Ñ≥[(‚Ñì_mŒΩ)* nq+i_q] #MB (58) similar to rel case but w/ q/œµ
    end

    # RSA equations (implementation of CLASS default switches)
    # println("k condition ", k*Œ∑‚Çì)
    # println("tau condition ", -5œÑ‚Çì‚Ä≤*Œ∑‚Çì*‚Ñã‚Çì)
    # if (k*Œ∑‚Çì > 45) println("k condition satisfied") end
    # if -5œÑ‚Çì‚Ä≤*Œ∑‚Çì*sqrt(H‚ÇÄ¬≤)< 1 println("tau condition satisfied") end
    rsa_on = false#(k*Œ∑‚Çì > 45) &&  (-5œÑ‚Çì‚Ä≤*Œ∑‚Çì*‚Ñã‚Çì<1)
    #*sqrt(H‚ÇÄ¬≤)< 1) #is this ‚Ñã or H0?
    if rsa_on
        # println("INSIDE RSA")
        #photons
        Œò[0] = Œ¶ - ‚Ñã‚Çì/k *œÑ‚Çì‚Ä≤ * v_b
        # Œò[1] = -2Œ¶‚Ä≤/k + (k^-2)*( œÑ‚Çì‚Ä≤‚Ä≤ * v_b + œÑ‚Çì‚Ä≤ * (‚Ñã‚Çì*v_b - csb¬≤ *Œ¥_b/k + k*Œ¶) )
        Œò[1] = ‚Ñã‚Çì/k * (  -2Œ¶‚Ä≤ + œÑ‚Çì‚Ä≤*( Œ¶ - csb¬≤*Œ¥_b  )
                         + ‚Ñã‚Çì/k*( œÑ‚Çì‚Ä≤‚Ä≤ - œÑ‚Çì‚Ä≤ )*v_b  )
        Œò[2] = 0
        #massless neutrinos
        ùí©[0] = Œ¶
        ùí©[1] = -2‚Ñã‚Çì/k *Œ¶‚Ä≤
        ùí©[2] = 0

        #set polarization to zero
        Œò·µñ[0] = 0
        Œò·µñ[1] = 0
        Œò·µñ[2] = 0

        # manual zeroing to avoid saving garbage
        ùí©‚Ä≤[:] = zeros(‚Ñì_ŒΩ+1)
        Œò‚Ä≤[:] = zeros(‚Ñì·µß+1)
        Œò·µñ‚Ä≤[:] = zeros(‚Ñì·µß+1)

    else
        #do usual ie
        # relativistic neutrinos (massless)
        ùí©‚Ä≤[0] = -k / ‚Ñã‚Çì * ùí©[1] - Œ¶‚Ä≤
        ùí©‚Ä≤[1] = k/(3‚Ñã‚Çì) * ùí©[0] - 2*k/(3‚Ñã‚Çì) *ùí©[2] + k/(3‚Ñã‚Çì) *Œ®
        for ‚Ñì in 2:(‚Ñì_ŒΩ-1)
            ùí©‚Ä≤[‚Ñì] =  k / ((2‚Ñì+1) * ‚Ñã‚Çì) * ( ‚Ñì*ùí©[‚Ñì-1] - (‚Ñì+1)*ùí©[‚Ñì+1] )
        end
        #truncation (same between MB and Callin06/Dodelson)
        ùí©‚Ä≤[‚Ñì_ŒΩ] =  k / ‚Ñã‚Çì  * ùí©[‚Ñì_ŒΩ-1] - (‚Ñì_ŒΩ+1)/(‚Ñã‚Çì *Œ∑‚Çì) *ùí©[‚Ñì_ŒΩ]


        # photons
        #Temp IE:
        # Œò[2] = IE_solve(‚à´Œò‚ÇÇ,x·µ¢,x,N·µß) #how to choose x·µ¢?

		#‚Ñì=0,1 DEs
        Œò‚Ä≤[0] = -k / ‚Ñã‚Çì * Œò[1] - Œ¶‚Ä≤
        Œò‚Ä≤[1] = k / (3‚Ñã‚Çì) * Œò[0] - 2k / (3‚Ñã‚Çì) * Œò[2] + k / (3‚Ñã‚Çì) * Œ® + œÑ‚Çì‚Ä≤ * (Œò[1] + v_b/3)

        # polarized photons
        #Polzn IE:
        # Œ† = IE_solve(‚à´Œ†,x·µ¢,x,N·µß) #not doing the internal solve rn, try later
		Œ† = ie.sŒ†(x) #call the spline
        Œò·µñ[2] = Œ† - Œò·µñ[0] - Œò[2]#get Œò·µñ‚Ä≤[2] from Œ† again - this easy?
		#‚Ñì=0,1 DEs
        Œò·µñ‚Ä≤[0] = -k / ‚Ñã‚Çì * Œò·µñ[1] + œÑ‚Çì‚Ä≤ * (Œò·µñ[0] - Œ† / 2)
        Œò·µñ‚Ä≤[1] = k / (3‚Ñã‚Çì) * Œò·µñ[0] - 2k / (3‚Ñã‚Çì) * Œò·µñ[2] + œÑ‚Çì‚Ä≤ * Œò·µñ[1] #usual ie term but just for ‚Ñì=1

    end
    #END RSA

    du[2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq+1:2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq+5] .= Œ¶‚Ä≤, Œ¥‚Ä≤, v‚Ä≤, Œ¥_b‚Ä≤, v_b‚Ä≤  # put non-photon perturbations back in
    return nothing
end

#FIXME need to import bessel functions somewhere?

# The RHSs of the IEs
# function ‚à´Œò‚ÇÇ(,,)
#
# end
#
# function ‚à´Œ†(,,)
#
# end
#
# # Volterra solver
# function IE_solve(‚à´f,N)
#
# end



#FIXME: don't need to copy all this code?
function initial_conditions(x·µ¢, ie::IE{T, BasicNewtonian}) where T
    k, ‚Ñì·µß, par, bg, ih, nq = ie.k, 2, ie.par, ie.bg, ie.ih, ie.nq
    TŒΩ =  (par.N_ŒΩ/3)^(1/4) *(4/11)^(1/3) * (15/ œÄ^2 *œÅ_crit(par) *par.Œ©_r)^(1/4)
    logqmin,logqmax=log10(TŒΩ/30),log10(TŒΩ*30)
    q_pts = xq2q.(bg.quad_pts,logqmin,logqmax)
    ‚Ñì_ŒΩ = ie.‚Ñì_ŒΩ
    ‚Ñì_mŒΩ =  ie.‚Ñì_mŒΩ
    u = zeros(T, 2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq+5)
    ‚Ñã‚Çì, ‚Ñã‚Çì‚Ä≤, Œ∑‚Çì, œÑ‚Çì‚Ä≤, œÑ‚Çì‚Ä≤‚Ä≤ = bg.‚Ñã(x·µ¢), bg.‚Ñã‚Ä≤(x·µ¢), bg.Œ∑(x·µ¢), ih.œÑ‚Ä≤(x·µ¢), ih.œÑ‚Ä≤‚Ä≤(x·µ¢)
    Œò, Œò·µñ, ùí©, ‚Ñ≥, Œ¶, Œ¥, v, Œ¥_b, v_b = unpack(u, ie)  # the Œò, Œò·µñ are mutable views (see unpack)

    H‚ÇÄ¬≤,a·µ¢¬≤ = bg.H‚ÇÄ^2,exp(x·µ¢)^2
    a·µ¢ = sqrt(a·µ¢¬≤)
    #These get a 3/3 since massive neutrinos behave as massless at time of ICs
    Œ©_ŒΩ =  7*(3/3)*par.N_ŒΩ/8 *(4/11)^(4/3) *par.Œ©_r
    f_ŒΩ = 1/(1 + 1/(7*(3/3)*par.N_ŒΩ/8 *(4/11)^(4/3)))

    # metric and matter perturbations
    Œ¶ = 1.0
    #choosing Œ¶=1 forces the following value for C, the rest of the ICs follow
    C = -( (15 + 4f_ŒΩ)/(20 + 8f_ŒΩ) )

    #trailing (redundant) factors are for converting from MB to Dodelson convention for clarity
    Œò[0] = -40C/(15 + 4f_ŒΩ) / 4
    Œò[1] = 10C/(15 + 4f_ŒΩ) * (k^2 * Œ∑‚Çì) / (3*k)
    Œò[2] = -8k / (15‚Ñã‚Çì * œÑ‚Çì‚Ä≤) * Œò[1]
   

    # ->apparently this does nothing TO BE CONSISTENT (even though this will give wrong ICs?)
    # Œò[2] = ie.sŒò2(x·µ¢)# call the spline, update Œò‚ÇÇ at top since we do not evolve it
    # Œ† = ie.sŒ†(x·µ¢) #call the spline
    
    Œò·µñ[0] = (5/4) * Œò[2]
    Œò·µñ[1] = -k / (4‚Ñã‚Çì * œÑ‚Çì‚Ä≤) * Œò[2]
    Œò·µñ[2] = (1/4) * Œò[2]
    # TO BE CONSISTENT (even though this will give wrong ICs?)
    # Œò·µñ[2] = Œ† - Œò·µñ[0] - Œò[2]#get Œò·µñ‚Ä≤[2] from Œ† again - this easy?

    Œ¥ = 3/4 *(4Œò[0]) #the 4 converts Œ¥Œ≥_MB -> Dodelson convention
    Œ¥_b = Œ¥
    #we have that Œòc = Œòb = ŒòŒ≥ = ŒòŒΩ, but need to convert Œò = - k v (i absorbed in v)
    v = -3k*Œò[1]
    v_b = v

    # neutrino hierarchy
    # we need x·µ¢ to be before neutrinos decouple, as always
    ùí©[0] = Œò[0]
    ùí©[1] = Œò[1]
    ùí©[2] = - (k^2 *Œ∑‚Çì^2)/15 * 1 / (1 + 2/5 *f_ŒΩ) * Œ¶  / 2 #MB
    #FIXME^put the C here for consistency
    for ‚Ñì in 3:‚Ñì_ŒΩ
        ùí©[‚Ñì] = k/((2‚Ñì+1)‚Ñã‚Çì) * ùí©[‚Ñì-1] #standard truncation
    end

    #massive neutrino hierarchy
    #It is confusing to use Œ®‚Ñì bc Œ® is already the metric pert, so will use ‚Ñ≥
    for (i_q, q) in zip(Iterators.countfrom(0), q_pts)
        œµ = ‚àö(q^2 + (a·µ¢*par.Œ£m_ŒΩ)^2)
        df0 = dlnf0dlnq(q,par)
        ‚Ñ≥[0* nq+i_q] = -ùí©[0]  *df0
        ‚Ñ≥[1* nq+i_q] = -œµ/q * ùí©[1] *df0
        ‚Ñ≥[2* nq+i_q] = -ùí©[2]  *df0  #drop quadratic+ terms in (ma/q) as in MB
        for ‚Ñì in 3:‚Ñì_mŒΩ #same scheme for higher-ell as for relativistic
            ‚Ñ≥[‚Ñì* nq+i_q] = q / œµ * k/((2‚Ñì+1)‚Ñã‚Çì) * ‚Ñ≥[(‚Ñì-1)*nq+i_q] #approximation of Callin06 (72), but add q/œµ - leaving as 0 makes no big difference
        end
    end

    u[2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq+1:(2(‚Ñì·µß+1)+(‚Ñì_ŒΩ+1)+(‚Ñì_mŒΩ+1)*nq+5)] .= Œ¶, Œ¥, v, Œ¥_b, v_b  # write u with our variables
    return u
end

#FIXME ignore source functions for now - nothing will need to change except struct arg
